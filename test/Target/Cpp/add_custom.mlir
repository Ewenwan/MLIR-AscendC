// RUN: ascendc-mlir-translate -ascendc-to-cpp %s | FileCheck %s -check-prefix=DEFAULT-ASCENDC
// RUN: ascendc-mlir-translate -ascendc-to-cpp -remove-ascendc-specifics %s | FileCheck %s -check-prefix=REMOVE-ASCENDC

// DEFAULT-ASCENDC: extern "C" __global__ __aicore__ void add_custom(GM_ADDR [[v1:.*]], GM_ADDR [[v2:.*]], GM_ADDR [[v3:.*]]) {
// REMOVE-ASCENDC: void add_custom(GM_ADDR [[v1:.*]], GM_ADDR [[v2:.*]], GM_ADDR [[v3:.*]]) {
func.func @add_custom(%x : !ascendc.GM_ADDR, %y : !ascendc.GM_ADDR, %z : !ascendc.GM_ADDR) {
// Struct Constructor
    %total_len = arith.constant 16384 : i32
    %use_core_num = arith.constant 8 : i32
    %block_len = arith.divui %total_len, %use_core_num : i32
    %tile_num = arith.constant 8 : i32
    %buffer_num = arith.constant 2 : i32
    %tile_length_pre_buffer = arith.divui %block_len, %tile_num : i32
    %tile_length = arith.divui %tile_length_pre_buffer, %buffer_num : i32

    %pipe = ascendc.create_pipe : !ascendc.TPipe

    %block_idx = ascendc.get_block_idx : i32
    %offset = arith.muli %block_len, %block_idx : i32
    // DEFAULT-ASCENDC: [[gmTensor13:.*]].SetGlobalBuffer((__gm__ half*)v1 + [[i12:.*]], [[i6:.*]]);
    // REMOVE-ASCENDC: [[gmTensor13:.*]].SetGlobalBuffer((half*)v1 + [[i12:.*]], [[i6:.*]]);
    %xGm = ascendc.create_global_tensor %x, %block_len, %offset : !ascendc.GM_ADDR -> !ascendc.GlobalTensor<16xf16>
    %yGm = ascendc.create_global_tensor %y, %block_len, %offset : !ascendc.GM_ADDR -> !ascendc.GlobalTensor<16xf16>
    %zGm = ascendc.create_global_tensor %z, %block_len, %offset : !ascendc.GM_ADDR -> !ascendc.GlobalTensor<16xf16>

    %inQueueX = ascendc.create_queue %pipe, %tile_length : !ascendc.TPipe -> !ascendc.TQue<VECIN, 2>
    %inQueueY = ascendc.create_queue %pipe, %tile_length : !ascendc.TPipe -> !ascendc.TQue<VECIN, 2>
    %outQueueZ = ascendc.create_queue %pipe, %tile_length : !ascendc.TPipe -> !ascendc.TQue<VECOUT, 2>

// Process
    %c0 = arith.constant 0 : i32
    %c1 = arith.constant 1 : i32
    %loop_count = arith.muli %tile_num, %buffer_num : i32
    scf.for %progress = %c0 to %loop_count step %c1 : i32 {
        %gm_offset = arith.muli %progress, %tile_length : i32

        // Copy in
        %xLocal = ascendc.alloc_tensor(%inQueueX) : !ascendc.TQue<VECIN, 2> -> !ascendc.LocalTensor<16xf16>
        %yLocal = ascendc.alloc_tensor(%inQueueY) : !ascendc.TQue<VECIN, 2> -> !ascendc.LocalTensor<16xf16>
        ascendc.data_copy %xLocal, %xGm[%gm_offset], %tile_length : !ascendc.GlobalTensor<16xf16> to !ascendc.LocalTensor<16xf16>
        ascendc.data_copy %yLocal, %yGm[%gm_offset], %tile_length : !ascendc.GlobalTensor<16xf16> to !ascendc.LocalTensor<16xf16>
        ascendc.enque %xLocal, %inQueueX : !ascendc.LocalTensor<16xf16> to !ascendc.TQue<VECIN, 2>
        ascendc.enque %yLocal, %inQueueY : !ascendc.LocalTensor<16xf16> to !ascendc.TQue<VECIN, 2>

        // Compute
        %xLocal_deque = ascendc.deque(%inQueueX) : !ascendc.TQue<VECIN, 2> -> !ascendc.LocalTensor<16xf16>
        %yLocal_deque = ascendc.deque(%inQueueY) : !ascendc.TQue<VECIN, 2> -> !ascendc.LocalTensor<16xf16>
        %zLocal = ascendc.alloc_tensor(%outQueueZ) : !ascendc.TQue<VECOUT, 2> -> !ascendc.LocalTensor<16xf16>
        ascendc.add %zLocal, %xLocal_deque, %yLocal_deque, %tile_length : (!ascendc.LocalTensor<16xf16>, !ascendc.LocalTensor<16xf16>) -> !ascendc.LocalTensor<16xf16>
        ascendc.enque %zLocal, %outQueueZ : !ascendc.LocalTensor<16xf16> to !ascendc.TQue<VECOUT, 2>
        ascendc.free_tensor (%inQueueX, %xLocal_deque) : !ascendc.LocalTensor<16xf16> from !ascendc.TQue<VECIN, 2>
        ascendc.free_tensor (%inQueueY, %yLocal_deque) : !ascendc.LocalTensor<16xf16> from !ascendc.TQue<VECIN, 2>

        // Copy out
        %zLocal_deque = ascendc.deque(%outQueueZ) : !ascendc.TQue<VECOUT, 2> -> !ascendc.LocalTensor<16xf16>
        ascendc.data_copy %zGm[%gm_offset], %zLocal_deque, %tile_length : !ascendc.LocalTensor<16xf16> to !ascendc.GlobalTensor<16xf16>
        ascendc.free_tensor (%outQueueZ, %zLocal_deque) : !ascendc.LocalTensor<16xf16> from !ascendc.TQue<VECOUT, 2>

        scf.yield
    }
    return
}

// /*
// * Copyright (c) Huawei Technologies Co., Ltd. 2023-2024. All rights reserved.
// * This code is generated by AscendC EmitC Builder.
// */

// #include "kernel_operator.h"
// using namespace AscendC;

// extern "C" __global__ __aicore__ void add_custom(GM_ADDR v1, GM_ADDR v2, GM_ADDR v3) {
//   int32_t i4 = 16384;
//   int32_t i5 = 8;
//   int32_t i6 = i4 / i5;
//   int32_t i7 = 8;
//   int32_t i8 = 2;
//   int32_t i9 = i6 / i7;
//   int32_t i10 = i9 / i8;
//   TPipe pipe;
//   int32_t i11 = GetBlockIdx();
//   int32_t i12 = i6 * i11;
//   GlobalTensor<half> gmTensor13;
//   gmTensor13.SetGlobalBuffer((__gm__ half*)v1 + i12, i6);
//   GlobalTensor<half> gmTensor14;
//   gmTensor14.SetGlobalBuffer((__gm__ half*)v2 + i12, i6);
//   GlobalTensor<half> gmTensor15;
//   gmTensor15.SetGlobalBuffer((__gm__ half*)v3 + i12, i6);
//   TQue<QuePosition::VECIN, 2> inQueue16;
//   pipe.InitBuffer(inQueue16, 2, i10 * sizeof(half));
//   TQue<QuePosition::VECIN, 2> inQueue17;
//   pipe.InitBuffer(inQueue17, 2, i10 * sizeof(half));
//   TQue<QuePosition::VECOUT, 2> outQueue18;
//   pipe.InitBuffer(outQueue18, 2, i10 * sizeof(half));
//   int32_t i19 = 0;
//   int32_t i20 = 1;
//   int32_t i21 = i7 * i8;
//   for (int32_t i22 = i19; i22 < i21; i22 += i20) {
//     int32_t i23 = i22 * i10;
//     LocalTensor<half> localTensor24 = inQueue16.AllocTensor<half>();
//     LocalTensor<half> localTensor25 = inQueue17.AllocTensor<half>();
//     DataCopy(localTensor24, gmTensor13[i23], i10);
//     DataCopy(localTensor25, gmTensor14[i23], i10);
//     inQueue16.EnQue(localTensor24);
//     inQueue17.EnQue(localTensor25);
//     LocalTensor<half> localTensor26 = inQueue16.DeQue<half>();
//     LocalTensor<half> localTensor27 = inQueue17.DeQue<half>();
//     LocalTensor<half> localTensor28 = outQueue18.AllocTensor<half>();
//     Add(localTensor28, localTensor26, localTensor27, i10);
//     outQueue18.EnQue(localTensor28);
//     inQueue16.FreeTensor(localTensor26);
//     inQueue17.FreeTensor(localTensor27);
//     LocalTensor<half> localTensor29 = outQueue18.DeQue<half>();
//     DataCopy(gmTensor15[i23], localTensor29, i10);
//     outQueue18.FreeTensor(localTensor29);
//   }
//   return;
// }
